# -*- coding: utf-8 -*-
"""sub_indices.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18l7lBKPilMH6685frFqenC0pbSXfq75u

# Sub-Indices Generation for Water Quality Analysis

This notebook illustrates the process of generating sub-indices for various water quality parameters based on the Bureau of Indian Standards (BIS) limits.
These sub-indices are standardized values calculated to ensure uniformity in evaluating water quality parameters, which are later aggregated into the Water Quality Index (WQI).

## Steps Covered:
1. Loading the dataset of water quality parameters
2. Handling missing values and preprocessing the data
3. Applying BIS limits to calculate sub-indices for each parameter
4. Visualizing sub-indices for better understanding
"""

import pandas as pd
import numpy as np

data = pd.read_csv('/content/India_2017.csv')
print(data.head())

# BIS limits -
# Ph = 6.5 to 8.5  NO Relaxation
# Th = 200 600
# CA = 75 200
# MG = 30 100
# Cl = 250 1000
# Sulphate = 200 400
# Nitrate = 75 NO Relaxation
# Flouride = 1 1.5
# TDS = 500 2000

print(np.sum(data.isna()))
# print(data['CA'].value_counts())
# print(data['MG'].value_counts())
# print(data['FLUORIDE'].value_counts())

data['CA'] = data['CA'].str.strip()
data['MG'] = data['MG'].str.strip()
data['FLUORIDE'] = data['FLUORIDE'].str.strip()
data.replace(['ND', 'BDL'], 0, inplace=True)

print(data['CA'].value_counts())

exclude_columns = ['LATITUDE', 'LONGITUDE']
data[data.columns.difference(exclude_columns)] = data[data.columns.difference(exclude_columns)].apply(pd.to_numeric, errors='coerce')

print(np.sum(data.isna()))

null_values = data[data['CHLORIDE'].isnull()]['CHLORIDE']
print(null_values)

data = data.dropna()
print(np.sum(data.isna()))

print(data['CA'].value_counts())

print(data)

data = data.reset_index(drop=True)

data.to_csv('temp.csv', index=False)

"""We use the following function for sub index generation -



\begin{equation}
S_i =
\begin{cases}
100 & \text{if } V \leq V_{\text{acceptable}} \\
\frac{V_{\text{permissible}} - V}{V_{\text{permissible}} - V_{\text{acceptable}}} \times 100 & \text{if } V_{\text{acceptable}} < V \leq V_{\text{permissible}} \\
0 & \text{if } V > V_{\text{permissible}}
\end{cases}
\end{equation}

"""

def generate_sub_indices(data, sub_indices):
  columns = ['TH', 'CA', 'MG', 'CHLORIDE', 'SULPHATE', 'FLUORIDE', 'TDS']
  acceptable_limits = {'TH':200,'CA':75,'MG':30,'CHLORIDE':250,'SULPHATE':200,'FLUORIDE':1,'TDS':500}
  permissible_limits = {'TH':600,'CA':200,'MG':100,'CHLORIDE':1000,'SULPHATE':400,'FLUORIDE':1.5,'TDS':2000}

  sub_indices = pd.DataFrame(index=data.index)

  sub_indices['PH'] = 0.0
  for i, value in enumerate(data['PH']):
    # print(f"Index: {i}, pH Value: {value}")  # Debug print
    if value >= 6.5 and value <= 8.5:
        sub_indices['PH'].at[i] = 100
        # print(f"Index: {i}, PH Value: {sub_indices['PH'].at[i]}")  # Debug print
    else:
        sub_indices['PH'].at[i] = 0



  for col in columns:
    sub_indices[col] = 0.0
    for i,value in enumerate(data[col]):
      if value <= acceptable_limits[col]:
        sub_indices[col].at[i] = 100
      elif value > permissible_limits[col]:
        sub_indices[col].at[i] = 0
      else:
        sub_indices[col].at[i] = (permissible_limits[col] - value)/(permissible_limits[col]-acceptable_limits[col])*100


  sub_indices['NITRATE'] = 0.0
  for i,value in enumerate(data['NITRATE']):
    if value <= 75:
      sub_indices['NITRATE'].at[i] = 100
    else :
      sub_indices['NITRATE'].at[i] = 0

  return sub_indices

sub_indices = pd.DataFrame()
sub_indices = generate_sub_indices(data, sub_indices)
print(sub_indices)

sub_indices.to_csv('temp2.csv', index=False)

print(sub_indices.shape)

new_order = ['PH','TH','CA','MG','CHLORIDE','SULPHATE','NITRATE','FLUORIDE','TDS']
sub_indices = sub_indices[new_order]
print(sub_indices)

sub_indices['LATITUDE'] = data['LATITUDE']
sub_indices['LONGITUDE'] = data['LONGITUDE']
new_order = ['LATITUDE','LONGITUDE','PH','TH','CA','MG','CHLORIDE','SULPHATE','NITRATE','FLUORIDE','TDS']

sub_indices = sub_indices[new_order]
print(sub_indices)

# Specify the columns you want to round
cols_to_round = ['PH', 'TH', 'CA', 'MG', 'CHLORIDE', 'SULPHATE', 'FLUORIDE', 'TDS', 'NITRATE']

# Round the specified columns to 2 decimal places
sub_indices[cols_to_round] = sub_indices[cols_to_round].round(2)

"""[0.03634713 0.66755045 0.03526272 0.06432972 0.03429169 0.02069839
 0.08058257 0.06093731 0.14412291]
"""

shap_weights = {'PH':0.03176855,
 'TH':0.58346045,
 'CA':0.03082074,
 'MG':0.05622624,
 'CHLORIDE':0.02997204,
 'SULPHATE':0.01809105,
 'NITRATE':0.07043174,
 'FLUORIDE':0.05326117,
 'TDS':0.12596802}

cols = ['PH','TH','CA','MG','CHLORIDE','SULPHATE','NITRATE','FLUORIDE','TDS']

sub_indices['AWQI'] = sum(sub_indices[col] * shap_weights[col] for col in cols)
print(sub_indices)

sub_indices['AWQI'] = sub_indices['AWQI'].round(2)
print(sub_indices)

sub_indices.to_csv('AWQI_India_2017.csv', index=False)

